				贪吃蛇游戏的构造
      设计概念主要是输出以及输入部分，先构建一个空间，在这空间里面输出贪吃蛇以及果实的位置，贪吃蛇
位置是通过键盘输入的信号来依次打印，然后不断刷新屏幕。
      接下来就要定义函数和结构体去封装各种不同的功能
	1.首先需要定义贪吃蛇和果实的结构体，还有贪吃蛇方向的枚举类型。
	struct SNAKE							
	{
			//存放贪吃蛇的坐标，用int x,y来保存;
			//存放贪吃蛇的长度，如果吃到果实就size++;
			//存放贪吃蛇的方向。初始化为向右。dir
			//存放贪吃蛇的速度，随着size++，speed也逐渐加快speed++
	}SNAKE[];
	struct FOOD
	{
			//存放果实的坐标,利用srand(time),rand()函数来随机生成位置。
			
	}
	enum DIR
	{
			//在定义四个方向
	}
	2.定义两个函数分别设置蛇和食物的坐标。
	void Snake_date()
	{
		*snake	//在定义一个指针指向贪吃蛇的结构体	
				//初始化贪吃蛇的数据		
	}
	void Food_date()
	{
		*food	//在定义一个指针指向果实的结构体
				//利用rand()函数随机初始化果实的坐标			
	}
	3.定义函数去构建一个界面空间，用于显示边界以及蛇和食物生成的位置。
	void Map()
	{
		char map[][] //定义二维数组，绘制边界。
					 //可利用循环给地图绘制边界。
					 //绘制完边界后绘制蛇和果实能移动的位置，(除了边界，其他位置先打印空格)。
		Snake();	 //调用蛇的参数
		map[*snake[]->x][*snake[]->y] ='A'//先将蛇头的位置定义好
		if()		 //利用if来判断果实的位置是否为' '空格，如果是就把果实位置赋值给map[][]。
		{

		}		
		for()
		{
					//利用循环在把贪吃蛇的其他身体给map[][]。
		}
					 //利用system("cls")来刷新屏幕。		 
	}
	4.定义绘制函数
	void print()
	{
				 //利用循环打印出map[][]里面的内容。
				 //Sleep(speed),随着长度而增加速度。

	}
	4.创建一个函数去接收玩家键盘输入的方向键（键入相反方向是不合法的）并改变蛇的坐标。
	可以利用kbhit（）函数来检测是否有键盘输入。
	void snake_move()
	{
		if(_kbhit()) //利用这个函数检测是否有键盘输入；
			switch(getch())	//判断键盘输入的信号，来进行调整贪吃蛇的方向
				case: 'w'
					  'W'
					  if (getch() != DOWN)
					  *snake->dir = UP ;
					break;
				case:
					break;
				case:
					break;
				case:
					break;

	}
	5.定义一个函数用于判断蛇的状态，例如是否吃到果实，如果吃到蛇身就加一，在判断蛇身
	是否撞到边界或者撞到自己。
	void Snake_flag()
	{
		if()	//判断蛇身的坐标是否与果实的位置重合
		{
				//如果重合 *snake->size++，*snake->speed++;
		}
		if()	//如果蛇身坐标等于上一次移动的位置或等于边界就返回return 0；
		{
				
		}	
	}
	6.在定义一个函数判断果实的状态，利用随机数rand（），在边界范围内随机生成，如果坐标
	与蛇的坐标重合就重新刷新果实的位置。	
	void FOOD_flag()
	{
		if()	//判断贪吃蛇的坐标是否等于果实的坐标
		{
				//如果等于就重新调用Food_date()函数来随机生成位置。
		}	
	}




